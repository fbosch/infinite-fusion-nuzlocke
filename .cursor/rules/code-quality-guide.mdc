# Code Quality Guide

**Principles**: Clean, readable, maintainable code with minimal complexity

## Core Guidelines

### Code Style
- **Write for humans**: Clear, descriptive names over cleverness
- **Single responsibility**: Each function/component does one thing
- **Early returns**: Use guard clauses to reduce nesting
- **Consistent patterns**: Follow established conventions

### Naming & Structure
```typescript
// ✅ Good: Descriptive names
const canUserBeProcessed = isUserEligibleForProcessing(user);
const FLUSH_DELAY_MS = 50; // Named constants

// ❌ Bad: Unclear names
const canProcess = chk(u);
setTimeout(flush, 50);
```

### Conditional Logic
```typescript
// ✅ Good: Guard clauses with early returns
function processUser(user: User | null) {
  if (!user) return null;
  if (!user.isActive) return null;
  if (!user.permissions.canProcess) return null;
  
  return processActiveUser(user);
}

// ❌ Bad: Deep nesting
function processUser(user: User | null) {
  if (user) {
    if (user.isActive) {
      if (user.permissions.canProcess) {
        return processActiveUser(user);
      }
    }
  }
  return null;
}
```

## Comments Strategy

### When to Comment
- **Business logic rationale** and trade-offs
- **Complex algorithms** or non-obvious math
- **Workarounds** for external constraints
- **Performance considerations**

### When NOT to Comment
- **Redundant explanations** of what the code does
- **Obvious variable assignments**
- **Simple conditional logic**

```typescript
// ❌ Bad: Redundant
// Set the user name to John
const userName = 'John';

// ✅ Good: Valuable context
// Use Levenshtein distance for fuzzy search when exact match fails
const matches = calculateLevenshteinDistance(query, candidateNames);
```

## CSS Class Management

### Use clsx for Conditional Classes
```typescript
// ✅ Good: Object syntax (preferred)
className={clsx(
  'base-class',
  {
    'active-class': isActive,
    'disabled-class': isDisabled
  }
)}

// ❌ Bad: String concatenation
className={`base-class ${isActive ? 'active-class' : ''}`}
```

## Best Practices

### Code Organization
- Group imports logically (standard library, third-party, local)
- Keep functions focused and under 20 lines
- Use early returns to reduce nesting (max 2 levels)
- Extract complex conditions into helper functions

### Error Handling
- Handle edge cases explicitly
- Write defensive code for unexpected inputs
- Use appropriate data structures for the task

### Refactoring
- Extract reusable patterns into functions
- Remove dead code and unused imports
- Simplify complex conditions and expressions
- Break down large functions into smaller ones

## Quick Rules

- **Max nesting**: 2 levels deep
- **Function length**: Under 20 lines
- **Variable names**: Self-documenting, no abbreviations
- **Comments**: Explain "why", not "what"
- **CSS classes**: Always use `clsx`, never string concatenation
- **Early returns**: Prefer over deep nesting
- **Constants**: Name magic numbers and strings
---
alwaysApply: true
description: Comprehensive code quality guidelines including style, comments, conditional logic, and best practices
---
