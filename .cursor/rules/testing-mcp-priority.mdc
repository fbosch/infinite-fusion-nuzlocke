---
description: Use Vitest MCP server for testing with fallback to terminal commands
globs: []
alwaysApply: true
---

# Testing Priority Rule

## Primary: Use Vitest MCP Server

Always use the Vitest MCP server tools for running tests when available:

### Required Setup
```typescript
// 1. Set project root first
mcp_vitest_set_project_root({ path: "/absolute/path/to/project" })

// 2. Run tests with MCP
mcp_vitest_run_tests({
  target: "path/to/test/file/or/directory",
  format: "detailed", // or "summary"
  showLogs: true // for debugging test failures
})
```

### When to Use MCP Tools
- ✅ Running specific test files
- ✅ Running tests in directories
- ✅ Getting structured test output
- ✅ Debugging test failures with logs
- ✅ Coverage analysis with `mcp_vitest_analyze_coverage`

### MCP Tool Benefits
- Structured JSON output for better AI analysis
- Built-in format detection (summary vs detailed)
- Console log capture for debugging
- Safety guards to prevent full project runs
- Better error reporting and insights

## Fallback: Terminal Commands

Only use terminal commands when MCP is unavailable or fails:

```bash
# Fallback commands
pnpm test:run -- path/to/test/file
pnpm test:run -- --run path/to/directory
pnpm test:coverage
```

### When Terminal Fallback is Acceptable
- MCP server is not available
- MCP tools return errors or fail
- Need to run commands not supported by MCP
- Interactive test watching (`pnpm test`)

## Test File Organization

### Test File Patterns
- `*.test.ts` or `*.spec.ts` - Unit tests
- `*.browser.test.ts` - Browser environment tests
- Place tests alongside source files or in `__tests__/` directories

### MCP Target Examples
```typescript
// Specific test file
mcp_vitest_run_tests({ target: "src/components/Button.test.ts" })

// Test directory
mcp_vitest_run_tests({ target: "src/stores/__tests__" })

// Multiple related files
mcp_vitest_run_tests({ target: "src/components" })
```

## Coverage Analysis

### Use MCP for Coverage
```typescript
mcp_vitest_analyze_coverage({
  target: "src/components",
  format: "detailed",
  exclude: ["**/*.test.*", "**/*.spec.*"]
})
```

### Benefits of MCP Coverage
- Line-by-line gap identification
- Actionable insights and recommendations
- Automatic exclusion of test files
- Detailed metrics for functions, branches, statements

## Implementation Guidelines

### Before Testing
1. Always call `mcp_vitest_set_project_root` first
2. Use absolute paths for project root
3. Use relative paths for test targets

### Test Execution
1. Start with MCP tools
2. Use `showLogs: true` for failing tests
3. Use `format: "detailed"` for complex scenarios
4. Fall back to terminal only if MCP fails

### Error Handling
- If MCP returns "No tests found", check file paths
- If MCP fails, explain why and use terminal fallback
- Always verify test results make sense

## Examples

### Good: MCP First Approach
```typescript
// 1. Set project root
await mcp_vitest_set_project_root({ path: "/absolute/project/path" });

// 2. Run tests with MCP
const result = await mcp_vitest_run_tests({
  target: "src/stores/__tests__/settings.test.ts",
  format: "detailed",
  showLogs: true
});

// 3. Only fall back if needed
if (!result.success) {
  console.log("MCP failed, using terminal fallback");
  await run_terminal_cmd({
    command: "pnpm test:run -- src/stores/__tests__/settings.test.ts"
  });
}
```

### Bad: Terminal First Approach
```bash
# Don't start with terminal commands
pnpm test:run -- src/stores/__tests__/settings.test.ts
```

## Test Development Workflow

### New Test Files
1. Create test file with proper naming
2. Use MCP to run and verify
3. Use `showLogs: true` to debug issues
4. Iterate using MCP for faster feedback

### Debugging Tests
1. Use MCP with `showLogs: true`
2. Use `format: "detailed"` for complex failures
3. Target specific failing tests or directories
4. Use coverage analysis to identify gaps

### CI/Production
- MCP tools work well in development
- Terminal commands may be needed in CI environments
- Document which approach works best for your setup

## Benefits of This Approach

### Developer Experience
- Faster feedback with structured output
- Better error messages and insights
- Consistent testing workflow
- Reduced cognitive load

### AI Assistant Benefits
- Structured JSON for better analysis
- Can provide specific actionable feedback
- Better understanding of test failures
- More accurate recommendations

### Maintenance
- Consistent approach across the project
- Better tooling integration
- Easier to debug and fix issues
- Future-proof testing strategy