---
description: Guidelines for when and how to write code comments, emphasizing self-documenting code over comments
globs: []
alwaysApply: true
---

# Code Comments Guidelines

Guidelines for writing meaningful comments while prioritizing self-documenting code through clear naming and structure. This rule is project-agnostic.

## Core Principles

- Prefer clear, descriptive names over comments
- Comments should explain why, not what
- Comment only when complexity warrants it
- Remove redundant comments that restate the code

## When Comments Are Needed

- Business logic rationale and trade-offs
- Complex algorithms or non-obvious math
- Workarounds or external constraints (APIs, browser quirks)
- Performance considerations and tuning

## Good vs Bad Comments

### ❌ Bad (Redundant)

```typescript
// Set the user name to John
const userName = 'John';

// Set loading to true
setLoading(true);

// Loop through items and collect active ones
items.forEach(item => {
  if (item.active) activeItems.push(item);
});
```

### ✅ Good (Valuable Context)

```typescript
// Use Levenshtein distance to support fuzzy search when exact match fails
const matches = calculateLevenshteinDistance(query, candidateNames);

// Debounce preview updates to avoid expensive re-computation on every keystroke
const PREVIEW_DEBOUNCE_MS = 16; // ~1 frame at 60fps
```

## Self-Documenting Code Patterns

### Use Descriptive Names

```typescript
// ❌ Unclear
const canProcess = chk(u);

// ✅ Clear
const canUserBeProcessed = isUserEligibleForProcessing(user);
```

### Extract Meaningful Functions

```typescript
// ❌ Complex inline logic
if (rec.enabled && rec.type === filter.type && !rec.deleted) {
  allowed = true;
}

// ✅ Self-documenting helper
const isAllowedRecord = (r: Record<string, unknown>, f: { type?: string }) => {
  return Boolean(r && (r as any).enabled) && (!f.type || (r as any).type === f.type) && !(r as any).deleted;
};

allowed = isAllowedRecord(record, filter);
```

### Use Descriptive Constants

```typescript
// ❌ Magic number
setTimeout(flush, 50);

// ✅ Named constant
const FLUSH_DELAY_MS = 50; // Prevent flicker between rapid updates
setTimeout(flush, FLUSH_DELAY_MS);
```

## When Comments Add Value

```typescript
// Aggregation rules:
// - Ignore soft-deleted records
// - Prefer user overrides over defaults
// - Cap total at MAX_LIMIT to protect downstream consumers
function computeAggregate(/* ... */) {}
```

## JSDoc for Public APIs

```typescript
/**
 * Computes aggregate statistics for a dataset.
 * Applies filtering, override precedence, and caps limits.
 */
export function computeAggregateStats(input: readonly number[]): number {
  // ...
}

// Trivial functions do not need JSDoc
export function getName(user: { name: string }): string {
  return user.name;
}
```

## Code Review Checklist

- Comments explain intent, trade-offs, or constraints
- No comments that restate obvious code
- Complex logic extracted into named functions
- Descriptive names and constants used

## Tooling Suggestions

- Enable `no-useless-comment`
- Enforce naming conventions
- Prefer constants over magic numbers
