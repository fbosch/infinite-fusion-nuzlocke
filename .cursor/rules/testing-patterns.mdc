---
description: Testing patterns and best practices for Valtio stores, browser mode tests, and version-based logic
globs: **/*.test.ts,**/*.browser.test.ts
alwaysApply: false
---

# Testing Patterns and Best Practices

## Core Testing Principles

### Browser Mode for Store Tests
- **Always use browser mode** for store tests that interact with localStorage
- **Use real APIs** instead of mocking DOM/browser features
- **Handle async subscriptions** properly with timing controls

### Valtio Store Testing Patterns

#### Store State Management
```typescript
// ✅ GOOD: Clear localStorage and reset store state
beforeEach(() => {
  clearLocalStorage();
  Object.assign(settingsStore, {
    moveEncountersBetweenLocations: false,
    version: '1.0.0',
  });
});
```

#### Testing Async Store Subscriptions
```typescript
// ✅ GOOD: Handle Valtio subscription timing
it('saves settings to localStorage when updated', async () => {
  settingsActions.toggleSetting();
  
  // Wait for subscription to fire
  await new Promise(resolve => setTimeout(resolve, 10));
  
  const stored = localStorage.getItem('nuzlocke-settings');
  expect(stored).not.toBeNull();
});
```

#### Testing Store Persistence Race Conditions
```typescript
// ✅ GOOD: Handle race conditions between state changes and localStorage
it('refreshes defaults when no settings are stored', async () => {
  clearLocalStorage();
  
  // Change state
  settingsStore.someValue = false;
  
  // Wait for any pending saves
  await new Promise(resolve => setTimeout(resolve, 20));
  
  // Clear again to ensure clean state
  clearLocalStorage();
  
  // Now test the action
  settingsActions.refreshDefaults();
});
```

## Version-Based Default Logic Testing

### Testing Backward Compatibility
```typescript
// ✅ GOOD: Test old vs new playthrough behavior
describe('Version-based Default Logic', () => {
  it('enables feature for old playthroughs (no version)', async () => {
    mockGetActivePlaythrough.mockReturnValue({
      id: 'old-playthrough',
      // No version field - indicates old playthrough
    } as any);

    const { settingsStore: freshStore } = await import('../settings?t=' + Date.now());
    expect(freshStore.moveEncountersBetweenLocations).toBe(true);
  });

  it('disables feature for new playthroughs (with version)', async () => {
    mockGetActivePlaythrough.mockReturnValue({
      id: 'new-playthrough',
      version: '1.0.0', // Has version - indicates new playthrough
    } as any);

    const { settingsStore: freshStore } = await import('../settings?t=' + Date.now());
    expect(freshStore.moveEncountersBetweenLocations).toBe(false);
  });
});
```

### Dynamic Import Testing in Browser Mode
```typescript
// ✅ GOOD: Use dynamic imports instead of require in browser tests
it('loads with different defaults', async () => {
  // Set up mock conditions
  mockGetActivePlaythrough.mockReturnValue(mockPlaythrough);
  
  // Use dynamic import with cache busting
  const { settingsStore: freshStore } = await import('../settings?t=' + Date.now());
  
  expect(freshStore.someValue).toBe(expectedValue);
});
```

## localStorage Testing Patterns

### Real localStorage Usage
```typescript
// ✅ GOOD: Use real localStorage in browser mode
beforeEach(() => {
  localStorage.clear();
});

it('persists settings correctly', () => {
  const settings = { key: 'value' };
  localStorage.setItem('app-settings', JSON.stringify(settings));
  
  const stored = localStorage.getItem('app-settings');
  expect(JSON.parse(stored!)).toEqual(settings);
});
```

### Testing localStorage Edge Cases
```typescript
// ✅ GOOD: Test corrupted data handling
it('handles corrupted localStorage data gracefully', async () => {
  localStorage.setItem('app-settings', 'invalid-json');
  
  const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
  
  const { settingsStore } = await import('../settings?t=' + Date.now());
  
  expect(settingsStore.someValue).toBe(defaultValue);
  expect(consoleSpy).toHaveBeenCalledWith(
    'Failed to load settings from localStorage:',
    expect.any(Error)
  );
  
  consoleSpy.mockRestore();
});
```

## Mocking Patterns

### What to Mock
```typescript
// ✅ GOOD: Mock application logic, not browser APIs
vi.mock('../playthroughs', () => ({
  getActivePlaythrough: vi.fn(),
}));

const mockGetActivePlaythrough = vi.mocked(getActivePlaythrough);
```

### What NOT to Mock
```typescript
// ❌ BAD: Don't mock browser APIs in browser mode
Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage,
});

// ✅ GOOD: Use real localStorage
localStorage.setItem('key', 'value');
```

## Zod Validation Testing

### Schema Validation Tests
```typescript
// ✅ GOOD: Test schema validation separately
describe('Schema Validation', () => {
  it('validates valid data', () => {
    const result = MySchema.safeParse(validData);
    expect(result.success).toBe(true);
  });

  it('rejects invalid data', () => {
    const result = MySchema.safeParse(invalidData);
    expect(result.success).toBe(false);
  });

  it('applies defaults for missing fields', () => {
    const result = MySchema.safeParse({});
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data).toEqual(expectedDefaults);
    }
  });
});
```

### Testing Validation in Actions
```typescript
// ✅ GOOD: Test validation in update functions
it('validates settings before saving', async () => {
  const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

  // Try to update with invalid data
  try {
    settingsActions.updateMultiple({
      invalidField: 'invalid-value',
    });
  } catch {
    // Expected to catch validation error
  }

  expect(consoleSpy).toHaveBeenCalledWith(
    'Invalid settings update:',
    expect.any(Object)
  );

  consoleSpy.mockRestore();
});
```

## Test Organization

### File Structure
```
src/stores/
├── __tests__/
│   ├── settings.browser.test.ts    # Browser mode tests
│   ├── validation.test.ts          # Pure function tests
│   └── integration.browser.test.ts # Integration tests
├── settings.ts
└── index.ts
```

### Test Naming Conventions
- **`.browser.test.ts`** - Tests requiring real browser environment
- **`.test.ts`** - Pure logic tests that can run in Node
- **`.integration.test.ts`** - Cross-module integration tests

### Test Structure
```typescript
describe('Feature Name', () => {
  beforeEach(() => {
    // Setup
  });

  afterEach(() => {
    // Cleanup
  });

  describe('Sub-feature', () => {
    it('should do specific thing', () => {
      // Test implementation
    });
  });
});
```

## Error Handling Testing

### Console Spy Patterns
```typescript
// ✅ GOOD: Test error logging
it('logs errors appropriately', () => {
  const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
  
  // Trigger error condition
  performErrorAction();
  
  expect(consoleSpy).toHaveBeenCalledWith(
    'Expected error message:',
    expect.any(Error)
  );
  
  consoleSpy.mockRestore();
});
```

### Graceful Degradation Testing
```typescript
// ✅ GOOD: Test fallback behavior
it('handles errors gracefully and defaults to safe values', () => {
  mockDependency.mockImplementation(() => {
    throw new Error('Dependency failed');
  });

  const result = functionUnderTest();
  
  expect(result).toBe(safeDefaultValue);
});
```

## Performance Testing

### Testing Debounced Functions
```typescript
// ✅ GOOD: Test debounced save operations
it('debounces save operations', async () => {
  // Trigger multiple rapid changes
  settingsActions.updateValue('a');
  settingsActions.updateValue('b');
  settingsActions.updateValue('c');
  
  // Wait for debounce delay
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // Should only save once with final value
  const stored = localStorage.getItem('settings');
  expect(JSON.parse(stored!).value).toBe('c');
});
```

## Common Pitfalls and Solutions

### Race Conditions
```typescript
// ❌ PROBLEM: Test fails due to timing
it('updates immediately', () => {
  settingsActions.update();
  expect(localStorage.getItem('settings')).not.toBeNull(); // Might fail
});

// ✅ SOLUTION: Handle async timing
it('updates with proper timing', async () => {
  settingsActions.update();
  await new Promise(resolve => setTimeout(resolve, 10));
  expect(localStorage.getItem('settings')).not.toBeNull();
});
```

### State Pollution
```typescript
// ❌ PROBLEM: Tests affect each other
beforeEach(() => {
  // Incomplete cleanup
});

// ✅ SOLUTION: Complete isolation
beforeEach(() => {
  localStorage.clear();
  vi.clearAllMocks();
  Object.assign(store, defaultState);
});
```

### Import Caching
```typescript
// ❌ PROBLEM: Module imports are cached
const { store } = require('../store'); // Always same instance

// ✅ SOLUTION: Dynamic imports with cache busting
const { store } = await import('../store?t=' + Date.now());
```

## Best Practices Checklist

### Before Writing Tests
- [ ] Identify if test needs browser mode (localStorage, DOM APIs)
- [ ] Plan mock strategy (application logic yes, browser APIs no)
- [ ] Consider async timing requirements
- [ ] Design for test isolation

### Test Implementation
- [ ] Use descriptive test names
- [ ] Test both success and error cases
- [ ] Handle async operations properly
- [ ] Clean up after each test
- [ ] Mock only application logic
- [ ] Use real browser APIs in browser mode

### Test Review
- [ ] Tests are isolated and don't affect each other
- [ ] Error cases are covered
- [ ] Async timing is handled correctly
- [ ] No brittle mocks of browser APIs
- [ ] Performance considerations are tested
- [ ] Version compatibility is verified

## Benefits of These Patterns

### Reliability
- **Real Environment Testing**: Browser mode provides realistic test conditions
- **Proper Async Handling**: Timing issues are addressed systematically
- **Comprehensive Coverage**: Both happy path and error scenarios

### Maintainability
- **Clear Patterns**: Consistent approach across all store tests
- **Easy Debugging**: Real APIs make debugging easier
- **Future-Proof**: Patterns scale with application growth

### Developer Experience
- **Fast Feedback**: Tests run quickly in browser mode
- **Realistic Results**: Tests catch real browser-specific issues
- **Clear Failures**: Good error messages and debugging info