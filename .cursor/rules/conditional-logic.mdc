---
description: Guidelines for writing clean conditional logic with early returns and avoiding deep nesting
globs: []
alwaysApply: true
---

# Conditional Logic and Early Returns

Rules for writing clean, readable conditional logic by avoiding nested if-else statements and preferring early returns.

## Core Principles

### Avoid Deep Nesting

- **Maximum nesting depth**: Keep conditional nesting to 2 levels or less
- **Early returns**: Use early returns to reduce nesting and improve readability
- **Guard clauses**: Use guard clauses at the beginning of functions
- **Invert conditions**: Invert conditions to handle edge cases first

### Prefer Linear Code Flow

- **Single responsibility**: Each conditional block should have a clear purpose
- **Readable flow**: Code should read top-to-bottom without complex branching
- **Avoid else-if chains**: Break complex else-if chains into separate functions or switch statements

## Early Return Patterns

### Guard Clauses

```typescript
// ✅ Good: Guard clauses with early returns
function processUser(user: User | null) {
  if (!user) return null;
  if (!user.isActive) return null;
  if (!user.permissions.canProcess) return null;

  // Main logic here with minimal nesting
  return processActiveUser(user);
}

// ❌ Bad: Nested if statements
function processUser(user: User | null) {
  if (user) {
    if (user.isActive) {
      if (user.permissions.canProcess) {
        return processActiveUser(user);
      }
    }
  }
  return null;
}
```

### Early Returns in Event Handlers

```typescript
// ✅ Good: Early returns reduce nesting
async function handleDrop(e: React.DragEvent) {
  e.preventDefault();
  e.stopPropagation();

  const pokemonName = e.dataTransfer.getData('text/plain');
  if (!pokemonName) return;

  // Handle swap operation if conditions are met
  if (dragState.canSwitch) {
    performSwapOperation();
    return;
  }

  // Get Pokemon data
  let pokemon = dragSnapshot.currentDragValue;
  if (!pokemon) {
    pokemon = await findPokemonByName(pokemonName);
    if (!pokemon) return;
  }

  // Perform final operation
  if (dragState.isFromDifferentCombobox) {
    performMoveOperation(pokemon);
  } else {
    onChange(pokemon);
  }
}

// ❌ Bad: Deep nesting makes logic hard to follow
async function handleDrop(e: React.DragEvent) {
  e.preventDefault();
  e.stopPropagation();

  const pokemonName = e.dataTransfer.getData('text/plain');
  if (pokemonName) {
    if (dragState.canSwitch) {
      performSwapOperation();
    } else {
      let pokemon = dragSnapshot.currentDragValue;
      if (!pokemon) {
        pokemon = await findPokemonByName(pokemonName);
        if (pokemon) {
          if (dragState.isFromDifferentCombobox) {
            performMoveOperation(pokemon);
          } else {
            onChange(pokemon);
          }
        }
      } else {
        if (dragState.isFromDifferentCombobox) {
          performMoveOperation(pokemon);
        } else {
          onChange(pokemon);
        }
      }
    }
  }
}
```

## Conditional Logic Patterns

### Switch Statements Over Else-If Chains

```typescript
// ✅ Good: Switch statement for multiple conditions
function getStatusColor(status: PokemonStatus): string {
  switch (status) {
    case 'alive':
      return 'text-green-500';
    case 'fainted':
      return 'text-red-500';
    case 'injured':
      return 'text-yellow-500';
    default:
      return 'text-gray-500';
  }
}

// ❌ Bad: Long else-if chain
function getStatusColor(status: PokemonStatus): string {
  if (status === 'alive') {
    return 'text-green-500';
  } else if (status === 'fainted') {
    return 'text-red-500';
  } else if (status === 'injured') {
    return 'text-yellow-500';
  } else {
    return 'text-gray-500';
  }
}
```

### Extract Complex Conditions

```typescript
// ✅ Good: Extract complex conditions into helper functions
function shouldShowPokemon(pokemon: Pokemon, filters: Filters): boolean {
  return (
    isPokemonAlive(pokemon) &&
    matchesTypeFilter(pokemon, filters) &&
    matchesRegionFilter(pokemon, filters)
  );
}

function isPokemonAlive(pokemon: Pokemon): boolean {
  return pokemon.status !== 'fainted';
}

function matchesTypeFilter(pokemon: Pokemon, filters: Filters): boolean {
  return !filters.type || pokemon.types.includes(filters.type);
}

// ❌ Bad: Complex inline conditions
function shouldShowPokemon(pokemon: Pokemon, filters: Filters): boolean {
  if (
    pokemon.status !== 'fainted' &&
    (!filters.type || pokemon.types.includes(filters.type)) &&
    (!filters.region || pokemon.region === filters.region)
  ) {
    return true;
  }
  return false;
}
```

## React Component Patterns

### Early Returns in Render Logic

```typescript
// ✅ Good: Early returns for different states
function PokemonCard({ pokemon }: { pokemon?: Pokemon }) {
  if (!pokemon) return <EmptyCard />;
  if (pokemon.status === 'fainted') return <FaintedCard pokemon={pokemon} />;
  if (pokemon.isLoading) return <LoadingCard />;

  return <ActivePokemonCard pokemon={pokemon} />;
}

// ❌ Bad: Nested conditional rendering
function PokemonCard({ pokemon }: { pokemon?: Pokemon }) {
  return (
    <div>
      {pokemon ? (
        pokemon.status === 'fainted' ? (
          <FaintedCard pokemon={pokemon} />
        ) : pokemon.isLoading ? (
          <LoadingCard />
        ) : (
          <ActivePokemonCard pokemon={pokemon} />
        )
      ) : (
        <EmptyCard />
      )}
    </div>
  );
}
```

### Hook Logic Simplification

```typescript
// ✅ Good: Early returns in hooks
function usePokemonData(pokemonId?: number) {
  const [data, setData] = useState<Pokemon | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!pokemonId) return;

    setLoading(true);
    fetchPokemon(pokemonId)
      .then(setData)
      .catch(console.error)
      .finally(() => setLoading(false));
  }, [pokemonId]);

  return { data, loading };
}

// ❌ Bad: Nested effect logic
function usePokemonData(pokemonId?: number) {
  const [data, setData] = useState<Pokemon | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (pokemonId) {
      setLoading(true);
      fetchPokemon(pokemonId)
        .then(pokemon => {
          if (pokemon) {
            setData(pokemon);
          }
        })
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [pokemonId]);

  return { data, loading };
}
```

## Validation and Error Handling

### Fail Fast Validation

```typescript
// ✅ Good: Fail fast with early returns
function validatePokemonData(pokemon: unknown): Pokemon | null {
  if (!pokemon || typeof pokemon !== 'object') return null;
  if (!('name' in pokemon) || typeof pokemon.name !== 'string') return null;
  if (!('id' in pokemon) || typeof pokemon.id !== 'number') return null;

  return pokemon as Pokemon;
}

// ❌ Bad: Nested validation
function validatePokemonData(pokemon: unknown): Pokemon | null {
  if (pokemon && typeof pokemon === 'object') {
    if ('name' in pokemon && typeof pokemon.name === 'string') {
      if ('id' in pokemon && typeof pokemon.id === 'number') {
        return pokemon as Pokemon;
      }
    }
  }
  return null;
}
```

## When to Allow Nesting

### Exception Cases

- **Simple ternary operators**: Single-line conditional assignments
- **Error boundaries**: When wrapping code in try-catch blocks
- **React conditional rendering**: Simple conditional JSX (1-2 levels max)

```typescript
// ✅ Acceptable: Simple ternary
const displayName = pokemon?.nickname || pokemon?.name || 'Unknown';

// ✅ Acceptable: Simple conditional rendering
return (
  <div>
    {isLoading ? (
      <Spinner />
    ) : (
      <PokemonList pokemon={pokemon} />
    )}
  </div>
);
```

## Refactoring Strategies

### Breaking Down Complex Functions

1. **Identify nested conditions**: Look for if-else chains more than 2 levels deep
2. **Extract helper functions**: Move complex conditions to named functions
3. **Use early returns**: Convert nested conditions to guard clauses
4. **Simplify boolean logic**: Use clear variable names for complex conditions

### Code Review Checklist

- [ ] Functions have minimal nesting (≤2 levels)
- [ ] Early returns are used for edge cases
- [ ] Complex conditions are extracted to helper functions
- [ ] Switch statements are used instead of long else-if chains
- [ ] Guard clauses are used at function start
- [ ] Boolean logic is clear and readable

## Tools and Techniques

### ESLint Rules

- Enable `max-depth` rule to limit nesting
- Use `complexity` rule to limit cyclomatic complexity
- Enable `no-else-return` rule to encourage early returns

### Refactoring Tools

- Use IDE refactoring to extract conditions
- Apply "invert if" refactoring to reduce nesting
- Use "extract method" for complex conditional blocks

## Benefits

### Readability

- **Linear flow**: Code reads naturally from top to bottom
- **Reduced cognitive load**: Less mental tracking of nested conditions
- **Clear intent**: Each condition serves a specific purpose

### Maintainability

- **Easier debugging**: Simpler control flow to trace
- **Easier testing**: Each condition can be tested independently
- **Easier modification**: Changes have less impact on surrounding code

### Performance

- **Early exits**: Avoid unnecessary computation
- **Reduced branching**: Less complex execution paths
- **Better optimization**: Simpler code for compiler optimization

## Common Mistakes to Avoid

### Anti-Patterns

- **Unnecessary else**: Using else after return statements
- **Deep nesting**: More than 2-3 levels of conditional nesting
- **Complex conditions**: Inline complex boolean expressions
- **Redundant checks**: Checking the same condition multiple times

### Code Smells

- Functions with high cyclomatic complexity
- Multiple levels of nested if-else statements
- Long else-if chains
- Complex boolean expressions without descriptive names

By following these guidelines, code becomes more readable, maintainable, and easier to debug while reducing cognitive complexity for developers.
