---
description: React hooks best practices including hook order consistency, dependency management, and custom hook patterns
globs: []
alwaysApply: true
---

# React Hook Rules

Rules for using React hooks correctly and avoiding common pitfalls.

## Core Hook Rules

### Hook Order Consistency

- **Always call hooks in the same order**: Hooks must be called in the same order on every render
- **Never call hooks conditionally**: Don't call hooks inside loops, conditions, or nested functions
- **Call hooks at the top level**: Only call hooks from React function components or custom hooks

### Early Returns and Hooks

- **Early returns must come after all hooks**: If a component needs to return early, do it after all hooks have been called
- **Never return before hooks**: This breaks the Rules of Hooks and causes runtime errors

### Correct Pattern

```typescript
// ✅ Good: All hooks called before early return
function MyComponent({ data }: Props) {
  const [state, setState] = useState(null);
  const memoizedValue = useMemo(() => computeValue(data), [data]);
  const ref = useRef(null);

  // Early return after all hooks
  if (!data) return null;

  return <div>{memoizedValue}</div>;
}
```

### Incorrect Pattern

```typescript
// ❌ Bad: Early return before hooks
function MyComponent({ data }: Props) {
  if (!data) return null; // This breaks hook order!

  const [state, setState] = useState(null);
  const memoizedValue = useMemo(() => computeValue(data), [data]);

  return <div>{memoizedValue}</div>;
}
```

## React 19+ Essentials

- **useEvent (stable)**: Use for event handlers that read latest props/state without re-subscribing. Avoid as a render-time computed value; use only for callbacks.
- **Actions and useActionState**: Model async UI actions (e.g., form submits) with built-in pending/error handling. Prefer over managing pending state manually.
- **useOptimistic**: Optimistic UI updates for async actions. Reconcile on settle.
- **useTransition / useDeferredValue**: Defer low-priority updates and expensive recalculations to keep UI responsive.
- **Server Components (framework-dependent)**: Prefer fetching and heavy computation on the server; keep client effects for external sync only.

## Hook Dependencies

### useEffect Dependencies

- **Include all dependencies**: Every value from component scope used inside useEffect should be in the dependency array
- **Use exhaustive-deps ESLint rule**: Enable this rule to catch missing dependencies
- **Avoid infinite loops**: Be careful with object/array dependencies that change on every render
- **Prefer useEvent for handlers**: If an effect only exists to keep a callback up-to-date, replace with `useEvent` and remove the effect
- **Use refs for imperative instances**: Store mutable external instances in `useRef` to avoid re-creating them due to dependency changes

### useMemo and useCallback Dependencies

- **Include all referenced values**: Any value from component scope used in the callback should be in dependencies
- **Don't over-optimize**: Only use these hooks when performance is actually an issue
- **Consider useCallback for event handlers**: Especially when passing to child components
- **Prefer useEvent for frequently changing reads**: For callbacks that need current state without re-creating the function, `useEvent` is often better than `useCallback`

## Custom Hook Rules

### Naming Convention

- **Start with 'use'**: All custom hooks must start with 'use'
- **Descriptive names**: Hook names should clearly indicate their purpose

### Custom Hook Structure

```typescript
// ✅ Good custom hook pattern
function useResource(resourceId: number) {
  const [data, setData] = useState<unknown | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!resourceId) return;

    setLoading(true);
    fetchResource(resourceId)
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [resourceId]);

  return { data, loading, error };
}
```

### Actions and Optimistic Updates

```typescript
// useActionState: model an async action with built-in pending/error state
function MyForm() {
  const [state, submitAction, isPending] = useActionState(async (prev, form) => {
    const result = await submitForm(new FormData(form));
    return result;
  }, null);

  return (
    <form action={submitAction}>
      <button disabled={isPending}>Submit</button>
    </form>
  );
}

// useOptimistic: show optimistic UI while an action is in flight
const [items, setItems] = useState<string[]>([]);
const [optimisticItems, addOptimisticItem] = useOptimistic(items, (current, newItem: string) => [newItem, ...current]);
```

## Common Hook Mistakes

### Avoid These Patterns

- **Conditional hook calls**: Never call hooks inside if statements
- **Hooks in loops**: Never call hooks inside for loops or while loops
- **Hooks in nested functions**: Never call hooks inside regular functions
- **Early returns before hooks**: Never return from component before all hooks are called
 - **Callbacks derived in effects**: Don’t use effects to recreate callbacks—use `useEvent` instead

### Performance Considerations

- **Don't overuse useMemo/useCallback**: Only use when there's a measurable performance benefit
- **Use React.memo for expensive components**: Wrap components that re-render unnecessarily
- **Consider useReducer for complex state**: When state logic becomes complex
 - **Use transitions and deferred values**: Keep input responsive while deferring heavy work

## Testing Hooks

### Testing Custom Hooks

- **Use @testing-library/react's renderHook**: Prefer `renderHook` from `@testing-library/react` (the hooks package is deprecated)
- **Test all hook states**: Loading, success, error, and edge cases
- **Mock external dependencies**: Mock API calls and external services

### Testing Components with Hooks

- **Test hook interactions**: Ensure hooks work together correctly
- **Test state changes**: Verify that state updates happen as expected
- **Test cleanup**: Ensure useEffect cleanup functions work properly

## Debugging Hook Issues

### Common Error Messages

- **"React has detected a change in the order of Hooks"**: Usually means early return before hooks
- **"Hooks can only be called inside the body of a function component"**: Hook called outside component
- **"Rules of Hooks"**: General hook rule violation

### Debugging Steps

1. **Check for early returns**: Ensure all hooks are called before any returns
2. **Verify hook order**: Make sure hooks are called in the same order every time
3. **Check conditional logic**: Ensure no hooks are called conditionally
4. **Review dependencies**: Check useEffect, useMemo, and useCallback dependencies
5. **Stale closures**: If a handler reads stale state, switch it to `useEvent`

## Best Practices

### Hook Organization

- **Group related hooks**: Keep related state and effects together
- **Order consistently**: Use a consistent order (state, effects, refs, custom hooks)
- **Extract complex logic**: Move complex hook logic to custom hooks

### State Management

- **Use appropriate state types**: useState for simple state, useReducer for complex state
- **Avoid prop drilling**: Use Context or state management libraries for deep prop passing
- **Keep state minimal**: Only store what's necessary in component state

### Effect Cleanup

- **Always clean up effects**: Return cleanup functions from useEffect when needed
- **Handle component unmounting**: Clean up subscriptions, timers, and event listeners
- **Use AbortController**: For canceling fetch requests on unmount

### Minimize useEffect Usage

- **Avoid useEffect when possible**: Prefer alternatives to useEffect for state synchronization
- **Use event handlers instead of effects**: Handle user interactions directly in event handlers
- **Use derived state instead of effects**: Compute values during render instead of storing them in state
- **Use useMemo for expensive calculations**: Instead of useEffect for computed values
- **Use useCallback for stable references**: Instead of useEffect for callback stability
- **Use useReducer for complex state**: Instead of multiple useEffect calls for related state
 - **Prefer useEvent over effect-based callback wiring**: Keep callbacks stable without dependency churn
 - **Prefer Actions for async UI flows**: Replace ad-hoc pending/error state managed in effects with Actions APIs

### When to Use useEffect

- **Data fetching**: Loading data from APIs
- **Subscriptions**: Setting up and cleaning up subscriptions
- **DOM measurements**: Reading DOM properties
- **Synchronizing with external systems**: Browser APIs, third-party libraries
- **Cleanup operations**: When component unmounts or dependencies change

### Avoid useEffect For

- **State synchronization with props**: Use props directly instead
- **Derived state**: Compute values during render
- **User interactions**: Use event handlers instead
- **Simple state updates**: Use direct state setters
- **Callback stability**: Use useCallback instead
 - **Keeping handlers fresh**: Use `useEvent` instead
